/*******************************************
题目描述：
    某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。
省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，
只要互相间接通过道路即可）。问最少还需要建设多少条道路？
输入：
    测试输入包含若干测试用例。每个测试用例的第一行给出两个正整数，分别是城镇数目N(<1000)
和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的
编号。为简单起见，城镇从1到N编号。当N为0是，输入结束，该用例不被处理。
输出：
    对每个测试用例，在1行里输出最少还需要建设的道路数目。
样例输入输出：
4 2
1 3
4 3
1
3 3
1 2
1 3
2 3
0
5 2
1 2
3 5
2
999 0
998

*******************************************/
#include<stdio.h>
using namespace std;
#define N 1000
int Tree[N];
int findRoot(int x){//查找某个结点所在树的根节点
    if(Tree[x]==-1) return x;
    else{
        int tmp = findRoot(Tree[x]);//递归直到找到根
        Tree[x] = tmp;
        return tmp;
    }
}

int main(){
    int n,m;
    while(scanf("%d",&n)!=EOF && n!=0){
        scanf("%d",&m);
        for(int i=1;i<=n;i++) Tree[i]=-1;  //初始时，所有结点都是孤立的集合，即其所在的集合只有一个结点，其本身就是树根结点
        while(m-- != 0){//读入边信息
            int a,b;
            scanf("%d%d",&a,&b);
            a = findRoot(a);
            b = findRoot(b);  //查找边的两个顶点所在的集合信息
            if(a != b) Tree[a] = b;  //若两个顶点不在同一个集合则合并这两个集合  让b做根节点
        }
        int ans = 0;
        for(int i=0;i<=n;i++)
            if(Tree[i] == -1) ans++;    //遍历数组，统计所有结点中根节点的个数
        printf("%d\n",--ans);  //答案即为在ans个集合间在修建ans-1条道路即可是所有结点联通
    }

    return 0;
}


