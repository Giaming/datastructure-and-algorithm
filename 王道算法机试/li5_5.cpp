/******************************************************
题目描述：
    在每年的校赛中，所有进入校赛的同学都会获得一件漂亮的t-shirt。
但是每当我们的工作人员把上百件的衣服从商品店运回赛场的时候，却是非常
累的，所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮组他们吗？
输入：
    输入包含多组数据。每组数据第一行是两个整数N,M（N<=100,M<=10000），N
表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是
赛场所在地，M则表示在城都有几条路。N=M=0表示输入结束。接下来M行，每行包括
3个整数A,B,C(1<=A,B<=N,1<=C<=1000),表示在路口A与路口B之间有一条路，我们的工作
人员需要C分钟的时间走过这条路。输入保证至少存在1条商店到赛场的路线。
    当输入为两个0时，输入结束。
输出：
    对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间。
样例输入和输出：
2 1
1 2 3
3
3 3
1 2 5
2 3 5
3 1 2
2

*****************************************************/
#include<stdio.h>
int ans[101][101];  //二维数组，其初始值即为该图邻接矩阵
int main(){
    int m,n;
    while(scanf("%d%d",&n,&m)!=EOF){
        if(n==0 && m==0) break;
        for(int i=1;i<=n;i++){  //n代表有几个路口
            for(int j=1;j<=n;j++){
                ans[i][j] = -1;  //对邻接矩阵初始化，我们用-1代表无穷
            }
            ans[i][i] = 0;//自己到自己的路径长度为0
        }
        while(m--){ //m代表有几条路
            int a,b,c;
            scanf("%d%d%d",&a,&b,&c);
            ans[a][b] = ans[b][a] = c;  //对邻接矩阵赋值，由于是无向图，该赋值操作要进行两次
        }
        for(int k=1;k<=n;k++){//k从1到N循环，依次代表允许经过的中间结点编号小于等于k
            for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++){//遍历所有ans[i][j]，判断其值保持原值还是将要被更新
                if(ans[i][k] == -1 || ans[k][j] == -1) continue;  //若两值中有一个值为无穷，则ans[i][j]不能经过结点k而被更新，跳过循环，保持原始
                if(ans[i][j] == -1 || ans[i][k]+ans[i][j]<ans[i][j])
                    ans[i][j] = ans[i][k]+ans[k][j];//小于则更新
            }
        }
        printf("%d\n",ans[1][n]);
    }
    return 0;
}


