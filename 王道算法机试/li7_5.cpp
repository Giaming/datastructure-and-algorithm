/*****************************************************
题目描述：
    2006年7月9号，那天xhd迫于无奈要从27号楼搬到3号楼，因为10号要封楼了。看着寝室的n件物品，xhd开始发呆，因为n是一个小于2000的整数，
实在是太多了，于是xhd决定随便搬2*k件过于就行了。但还是会很累的，因为2*k也不小是一个不大于n的整数。幸运的是xhd根据多年搬东西的经验发现
每搬一次的疲劳度是和左右手的物品的重量差的平方成正比（这里补充一句，xhd每次搬两件东西，左手一件右手一件）。例如，xhd左手拿重量为3的物品，
右手拿重量为6的物品，则他搬完这次的疲劳度为(6-3)^2=9.现在可怜的xhd希望知道搬完这2*k件物品后的最佳状态是怎样的（也就是最低的疲劳度）。
输入：
    每组输入数据有两行，第一行有两个数n,k(2<=2*k<=n<2000)。第二行有n个整数分别表示n件物品的重量（重量是一个小于2^15的正整数）
输出：
    对应每组输入数据，输出数据只有一个表示他的最少的疲劳度，每个一行。
样例输入和输出：
2 1
1 3
4

******************************************************/
#include<stdio.h>
#include<algorithm>
using namespace std;
#define INF 0x7ffffff;  //预定义最大的int值取无穷
int list[2001];  //保存每个物品重量
int dp[1001][2001];  //保存每个状态

int main(){
    int n,k;
    while(scanf("%d%d",&n,&k)!=EOF){
        for(int i=1;i<=n;i++){
            scanf("%d",&list[i]);
        }
        sort(list+1,list+1+n);   //使所有物品按照重量递增排序
        for(int i=1;i<=n;i++){
            dp[0][i] = 0;
        }
        for(int i=1;i<=k;i++){//递推求得每个状态
            for(int j=2*i;j<=n;j++){
                if(j>2*i)  //若j>2*i则表明，最后两个物品可以不配对，即前j-1件物品足够配成i对，dp[i][j]可以有dp[i][j-1]转移而来，其值先被设置为dp[i][j-1]
                    dp[i][j] = dp[i][j-1];
                else
                    dp[i][j] = INF;  //若j==2*i，说明最后两件物品必须配对，否则前j件物品配不成i对，所以其状态不能由dp[i][j-1]转移而来，dp[i][j]先设置为正无穷
                if(dp[i][j]>dp[i-1][j-2]+(list[j]-list[j-1])*(list[j]-list[j-1]))
                    dp[i][j] = dp[i-1][j-2] + (list[j]-list[j-1])*(list[j]-list[j-1]);
            }
        }
        printf("%d\n",dp[k][n]);
    }
    return 0;
}








